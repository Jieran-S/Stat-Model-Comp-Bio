5e4 -1
SimFiftyKAll <- lapply(c(1,2), function(x){
Sim <- gibbsRain(5e4)
Sim[, c("RFreq", "CFreq") := lapply(.SD, function(x) cumsum(x == 1)/.N), .SD = colnames(Sim) ]
Sim[, rowNo := 1:.N]
})
SimFiftyKAll <- rbindlist(SimFiftyKAll, idcol = "Trail")
SimFiftyKAll$Trail <- as.factor(SimFiftyKAll$Trail)
ggplot(SimFiftyKAll, aes(x = rowNo,  col = Trail)) +
geom_line(aes(y = RFreq, col = Trail, linetype = "R")) +
geom_line(aes(y = CFreq, col = Trail, linetype = "C" )) +
labs(x = "steps", y = "Frequency") +
scale_linetype_manual(values = c("solid", "dashed"))
gibbsRain <- function(number_samples){
# Constants
P_C = 0.5
P_S_g_C = matrix(c(1,0,0.1,0.5,0.9,0.5),ncol = 3)
P_R_g_C = matrix(c(1,0,0.8,0.2,0.2,0.8),ncol = 3)
P_G_g_S_R = matrix(c(1,1,0,0,1,0,1,0,
0.99,0.90,0.90,0.01,0.01,0.1,0.1,0.99),ncol = 4)
# INITALIZE
states <- matrix(T, number_samples+1,
ncol = 2,
dimnames = list(c(),c("Rain","Cloudy")))
for (i in 1:number_samples) {
if (runif(1) >= 0.5) {
# Update Rain
a <- P_R_g_C[2-states[i,"Cloudy"],2]*P_G_g_S_R[1,3]
b <- a + P_R_g_C[2-states[i,"Cloudy"],3]*P_G_g_S_R[2,3]
states[i+1,"Rain"] <- runif(1) <= a/b
} else {
# Update Cloudy
a <- P_C*P_S_g_C[1,2]*P_R_g_C[1,3-states[i,"Rain"]]
b <- a + (1-P_C)*P_S_g_C[2,2]*P_R_g_C[2,3-states[i,"Rain"]]
states[i+1,"Cloudy"] <- runif(1) <= a/b
}
}
return (states)
}
gibbSamples <- gibbsRain(100)
gibbSamples
gibbSamples_50k_1 <- gibbsRain(50000)
gibbSamples_50k_2 <- gibbsRain(50000)
rollEsts_50k_1 <- rollingEstimate(gibbSamples_50k_1)
rollingEstimate <- function(gibbSamples){
cloudy <- as.numeric(gibbSamples[,"Cloudy"])
rain <- as.numeric(gibbSamples[,"Rain"])
rollingEstimateCloudy <- cumsum(cloudy) / seq_along(cloudy)
rollingEstimateRain <- cumsum(rain) / seq_along(rain)
return(list(rollingEstimateCloudy,rollingEstimateRain))
}
gibbSamples_50k_1 <- gibbsRain(50000)
gibbSamples_50k_2 <- gibbsRain(50000)
rollEsts_50k_1 <- rollingEstimate(gibbSamples_50k_1)
rollEsts_50k_2 <- rollingEstimate(gibbSamples_50k_2)
plot(rollEsts_50k_1[[1]][1:2000],type = "l",col="red")
lines(rollEsts_50k_2[[1]][1:2000])
plot(rollEsts_50k_1[[2]][1:2000],type = "l",col="red")
lines(rollEsts_50k_2[[2]][1:2000])
SimFiftyKAll <- lapply(c(1,2), function(x){
Sim <- gibbsRain(5e4)
Sim[, c("RFreq", "CFreq") := lapply(.SD, function(x) cumsum(x == 1)/seq_len(.N)), .SD = colnames(Sim) ]
Sim[, rowNo := 1:.N]
})
SimFiftyKAll <- lapply(c(1,2), function(x){
Sim <- gibbsRain(5e4)
Sim[, c("RFreq", "CFreq") := lapply(.SD, function(x) cumsum(x == 1)/seq_len(.N)), .SD = colnames(Sim) ]
Sim[, rowNo := 1:.N]
})
seq_len(3)
SimFiftyKAll <- lapply(c(1,2), function(x){
Sim <- gibbsRain(5e4)
Sim[, c("RFreq", "CFreq") := lapply(.SD, function(x) cumsum(x == 1)/seq_len(.N)), .SD = colnames(Sim) ]
Sim[, rowNo := 1:.N]
})
Sim <- gibbsRain(5e4)
is.data.table(Sim)
P_C = 0.5
P_S_g_C = matrix(c(1,0,0.1,0.5,0.9,0.5),ncol = 3)
P_R_g_C = matrix(c(1,0,0.8,0.2,0.2,0.8),ncol = 3)
P_G_g_SR = matrix(c(1,1,0,0,1,0,1,0,
0.99,0.90,0.90,0.01,0.01,0.1,0.1,0.99),ncol = 4)
# colnames: S, W, R, T, F
P_C_g_SWR = matrix(rep(c(1,0), each = 5), ncol = 5)
# if R is T or F
for (i in c(0,1)) {
# if c is T or F
for (j in c(0, 1)){
TotalP <- mean(unlist(lapply(c(0,1), function(x) P_R_g_C[which(x == P_R_g_C[,1]),i+2] * P_S_g_C[which(x == P_S_g_C[,1]), 2])))
P_C_g_SWR[i+1,j+4] <- P_R_g_C[which(j != P_R_g_C[,1]),i+2] * P_S_g_C[which(j != P_S_g_C[,1]), 2] * P_C / TotalP
}
}
gibbsRain <- function(n) {
# define P_C_g_SWR function
ProbCgivenSWR <- function(Rprob) {
prob <- P_C_g_SWR[which(P_C_g_SWR[,3] == Rprob),4]
return(prob)
}
ProbRgivenC<- function(Cprob) {
prob <- P_R_g_C[which(P_R_g_C[,1] == Cprob), 2]
return(prob)
}
# initiation
CProb <- rep(NA, n)
RProb <- rep(NA, n)
CProb[1] <- rbinom(1,1,0.5)
RProb[1] <- rbinom(1,1,0.5)
# Assigning probability in each round
for (i in 2:n){
CProb[i] <- rbinom(1, 1, ProbCgivenSWR(RProb[i-1]))
RProb[i] <- rbinom(1, 1, ProbRgivenC(CProb[i]))
}
resultsDT <- data.table(CProb = CProb, RProb = RProb)
}
Sim <- gibbsRain(5e4)
is.data.table(Sim)
SimFiftyKAll <- lapply(c(1,2), function(x){
Sim <- gibbsRain(5e4)
Sim[, c("RFreq", "CFreq") := lapply(.SD, function(x) cumsum(x == 1)/seq_len(.N)), .SD = colnames(Sim) ]
Sim[, rowNo := 1:.N]
})
SimFiftyKAll <- rbindlist(SimFiftyKAll, idcol = "Trail")
SimFiftyKAll$Trail <- as.factor(SimFiftyKAll$Trail)
ggplot(SimFiftyKAll, aes(x = rowNo,  col = Trail)) +
geom_line(aes(y = RFreq, col = Trail, linetype = "R")) +
geom_line(aes(y = CFreq, col = Trail, linetype = "C" )) +
labs(x = "steps", y = "Frequency") +
scale_linetype_manual(values = c("solid", "dashed"))
SimFiftyKAll <- lapply(c(1,2), function(x){
Sim <- gibbsRain(5e4)
Sim[, c("RFreq", "CFreq") := lapply(.SD, function(x) cumsum(x == 1)/seq_len(.N)), .SD = colnames(Sim) ]
Sim[, rowNo := 1:.N]
})
SimFiftyKAll <- rbindlist(SimFiftyKAll, idcol = "Trail")
SimFiftyKAll$Trail <- as.factor(SimFiftyKAll$Trail)
ggplot(SimFiftyKAll, aes(x = rowNo,  col = Trail)) +
geom_line(aes(y = RFreq, col = Trail, linetype = "R")) +
geom_line(aes(y = CFreq, col = Trail, linetype = "C" )) +
labs(x = "steps", y = "Frequency") +
scale_linetype_manual(values = c("solid", "dotted"))
SimBurned <- gibbsRain(13e3)
(RMargBurned <- SimBurned[RProb == 1 & CProb == 1, .N/100] * CPost + SimBurned[RProb == 1 & CProb == 0, .N/100] * (1-CPost))
rollEsts <- rollingEstimate(gibbSamples)
cloudy_acf <- acf(rollEsts[[1]])
rain_acf <- acf(rollEsts[[2]])
100/(1+2*sum(cloudy_acf$acf))
100/(1+2*sum(rain_acf$acf))
?acf
acf(SimOneHund$CProb, type = "correlation")
acf(SimOneHund$RProb, type = "correlation")
acf(SimOneHund$CProb, type = "correlation")
acf(SimOneHund$RProb, type = "correlation")
acf(SimOneHund$CProb, type = "correlation", main = "Cloudy")
acf(SimOneHund$RProb, type = "correlation", main = "Rain")
acf(SimOneHund$CProb, type = "correlation", main = "Cloudy")
acf(SimOneHund$CProb, type = "correlation", ylab = "Cloudy")
acf(SimOneHund$RProb, type = "correlation", ylab = "Rain")
cloudyACF <- acf(SimOneHund$CProb, type = "correlation", ylab = "Cloudy")
cloudyACF
typeof(cloudyACF)
length(cloudyACF)
View(cloudyACF)
cloudyACF$lag
cloudyACF <- acf(SimOneHund$CProb, type = "correlation", ylab = "Cloudy")
rainACF <- acf(SimOneHund$RProb, type = "correlation", ylab = "Rain")
ESSCloudy <- 100/(1 + 2*sum(cloudyACF$acf))
ESSRain <- 100/(1 + 2*sum(rainACF$acf))
cat(sprintf("Cloudy ESS: %s, Rain ESS: %s", ESSCloudy, ESSRain))
SimBurned <- gibbsRain(13e3)
(RMargBurned <- SimBurned[RProb == 1 & CProb == 1, .N/100] * CPost + SimBurned[RProb == 1 & CProb == 0, .N/100] * (1-CPost))
SimFiftyKAll <- lapply(c(1,2), function(x){
Sim <- gibbsRain(5e4)
Sim[, c("RFreq", "CFreq") := lapply(.SD, function(x) cumsum(x == 1)/seq_len(.N)), .SD = colnames(Sim) ]
Sim[, rowNo := 1:.N]
})
SimFiftyKAll <- rbindlist(SimFiftyKAll, idcol = "Trail")
SimFiftyKAll$Trail <- as.factor(SimFiftyKAll$Trail)
ggplot(SimFiftyKAll, aes(x = rowNo,  col = Trail)) +
geom_line(aes(y = RFreq, col = Trail, linetype = "R")) +
geom_line(aes(y = CFreq, col = Trail, linetype = "C" )) +
labs(x = "steps", y = "Frequency") +
scale_linetype_manual(values = c("solid", "dotted"))
library(coda)
library(data.table)
RMarg <- SimOneHund[RProb == 1, .N/100]
cat(sprintf("The margina probability is %s", RMarg))
gibbsRain <- function(number_samples){
# Constants
P_C = 0.5
P_S_g_C = matrix(c(1,0,0.1,0.5,0.9,0.5),ncol = 3)
P_R_g_C = matrix(c(1,0,0.8,0.2,0.2,0.8),ncol = 3)
P_G_g_S_R = matrix(c(1,1,0,0,1,0,1,0,
0.99,0.90,0.90,0.01,0.01,0.1,0.1,0.99),ncol = 4)
# INITALIZE
states <- matrix(T, number_samples,
ncol = 2,
dimnames = list(c(),c("Rain","Cloudy")))
for (i in 1:(number_samples-1)) {
if (runif(1) >= 0.5) {
# Update Rain
a <- P_R_g_C[2-states[i,"Cloudy"],2]*P_G_g_S_R[1,3]
b <- a + P_R_g_C[2-states[i,"Cloudy"],3]*P_G_g_S_R[2,3]
states[i+1,"Rain"] <- runif(1) <= a/b
states[i+1,"Cloudy"] <- states[i,"Cloudy"]
} else {
# Update Cloudy
a <- P_C*P_S_g_C[1,2]*P_R_g_C[1,3-states[i,"Rain"]]
b <- a + (1-P_C)*P_S_g_C[2,2]*P_R_g_C[2,3-states[i,"Rain"]]
states[i+1,"Cloudy"] <- runif(1) <= a/b
states[i+1,"Rain"] <- states[i,"Rain"]
}
}
return (states)
}
gibbSamples <- gibbsRain(100)
colMeans(gibbSamples)
sum(gibbSamples[gibbSamples[,"Cloudy"] == 1 , "Rain"])/100 + sum(gibbSamples[gibbSamples[,"Cloudy" ] == 0, "Rain" ])/100
sum(gibbSamples[, "Rain"])/100
RMarg <- colMeans(gibbSamples[, "Rain"])
RMarg <- mean(gibbSamples[, "Rain"])
cat(sprintf("The margina probability is %s", RMarg))
rollingEstimate <- function(gibbSamples){
cloudy <- 1*(gibbSamples[,"Cloudy"])
rain <- 1*(gibbSamples[,"Rain"])
rollingEstimateCloudy <- cumsum(cloudy) / seq_along(cloudy)
rollingEstimateRain <- cumsum(rain) / seq_along(rain)
return(list(rollingEstimateCloudy,rollingEstimateRain))
}
rollEsts <- rollingEstimate(gibbSamples)
cloudy_acf <- acf(rollEsts[[1]],main = "Cloudy")
rain_acf <- acf(rollEsts[[2]], main = "Rain")
ESSCloudy <- 100/(1+2*sum(cloudy_acf$acf))
ESSRain   <- 100/(1+2*sum(rain_acf$acf))
cat(sprintf("Cloudy ESS: %s, /n Rain ESS: %s", ESSCloudy, ESSRain))
rollingEstimate <- function(gibbSamples){
cloudy <- 1*(gibbSamples[,"Cloudy"])
rain <- 1*(gibbSamples[,"Rain"])
rollingEstimateCloudy <- cumsum(cloudy) / seq_along(cloudy)
rollingEstimateRain <- cumsum(rain) / seq_along(rain)
return(list(rollingEstimateCloudy,rollingEstimateRain))
}
rollEsts <- rollingEstimate(gibbSamples)
cloudy_acf <- acf(rollEsts[[1]],main = "Cloudy")
rain_acf <- acf(rollEsts[[2]], main = "Rain")
ESSCloudy <- 100/(1+2*sum(cloudy_acf$acf))
ESSRain   <- 100/(1+2*sum(rain_acf$acf))
cat(sprintf("Cloudy ESS: %s, \n Rain ESS: %s", ESSCloudy, ESSRain))
rollingEstimate <- function(gibbSamples){
cloudy <- 1*(gibbSamples[,"Cloudy"])
rain <- 1*(gibbSamples[,"Rain"])
rollingEstimateCloudy <- cumsum(cloudy) / seq_along(cloudy)
rollingEstimateRain <- cumsum(rain) / seq_along(rain)
return(list(rollingEstimateCloudy,rollingEstimateRain))
}
rollEsts <- rollingEstimate(gibbSamples)
cloudy_acf <- acf(rollEsts[[1]],main = "Cloudy")
rain_acf <- acf(rollEsts[[2]], main = "Rain")
ESSCloudy <- 100/(1+2*sum(cloudy_acf$acf))
ESSRain   <- 100/(1+2*sum(rain_acf$acf))
cat(sprintf("Cloudy ESS: %s, \n
Rain ESS: %s", ESSCloudy, ESSRain))
rollingEstimate <- function(gibbSamples){
cloudy <- 1*(gibbSamples[,"Cloudy"])
rain <- 1*(gibbSamples[,"Rain"])
rollingEstimateCloudy <- cumsum(cloudy) / seq_along(cloudy)
rollingEstimateRain <- cumsum(rain) / seq_along(rain)
return(list(rollingEstimateCloudy,rollingEstimateRain))
}
rollEsts <- rollingEstimate(gibbSamples)
cloudy_acf <- acf(rollEsts[[1]],main = "Cloudy")
rain_acf <- acf(rollEsts[[2]], main = "Rain")
ESSCloudy <- 100/(1+2*sum(cloudy_acf$acf))
ESSRain   <- 100/(1+2*sum(rain_acf$acf))
cat(sprintf("Cloudy ESS: %s, \n
Rain ESS: %s", ESSCloudy, ESSRain))
# sample two 50k long chains
gibbSamples_50k_1 <- gibbsRain(50000)
gibbSamples_50k_2 <- gibbsRain(50000)
rollEsts_50k_1 <- rollingEstimate(gibbSamples_50k_1)
rollEsts_50k_2 <- rollingEstimate(gibbSamples_50k_2)
# plot chains
plot(rollEsts_50k_1[[1]][1:25000],type = "l",col="red",ylim = c(0,1),main = "Cloudy")
lines(rollEsts_50k_2[[1]][1:25000])
plot(rollEsts_50k_1[[2]][1:25000],type = "l",col="red",ylim = c(0,1),main = "Rain")
lines(rollEsts_50k_2[[2]][1:25000])
# plot more then two chains
plot(rollingEstimate(gibbsRain(20000))[[1]],type = "l",col="red",ylim = c(0,1),main = "Cloudy")
for (col in c("black","blue","cyan","purple","orange")) {
lines(rollingEstimate(gibbsRain(20000))[[1]],col = col)
}
plot(rollingEstimate(gibbsRain(20000))[[2]],type = "l",col="red",ylim = c(0,1),main = "Rain")
for (col in c("black","blue","cyan","purple","orange")) {
lines(rollingEstimate(gibbsRain(20000))[[2]],col = col)
}
library(coda)
mcmclist <- list()
for (i in 1:10) {
mcmclist[[i]] <- mcmc(gibbsRain(10000)*1)
}
mcmclist <- mcmc.list(mcmclist)
gelman.plot(mcmclist)
gibbSamplesDT <- as.data.table(gibbSamples)
gibbSamplesDT[, RFreq := cumsum(Rain)/seq_len(.N)]
gibbSamplesDT[, CFreq := cumsum(Cloudy)/seq_len(.N)]
cloudyACF <- acf(gibbSamplesDT$CFreq, main = "Cloudy")
ESSCloudy
100/(1+2*sum(cloudyACF$acf))
# sample two 50k long chains
gibbSamples_50k_1 <- gibbsRain(50000)
gibbSamples_50k_2 <- gibbsRain(50000)
rollEsts_50k_1 <- rollingEstimate(gibbSamples_50k_1)
rollEsts_50k_2 <- rollingEstimate(gibbSamples_50k_2)
# plot chains
plot(rollEsts_50k_1[[1]][1:25000],type = "l",col="red",ylim = c(0,1), main = "Cloudy",
ylab = "Estimated TRUE frequency")
lines(rollEsts_50k_2[[1]][1:25000])
plot(rollEsts_50k_1[[2]][1:25000],type = "l",col="red",ylim = c(0,1), main = "Rain",
ylab = "Estimated TRUE frequency")
lines(rollEsts_50k_2[[2]][1:25000])
# plot more then two chains to check on a more general convergence burn-in time
plot(rollingEstimate(gibbsRain(20000))[[1]],type = "l",col="red",ylim = c(0,1),main = "Cloudy",
ylab = "Estimated TRUE frequency")
for (col in c("black","blue","cyan","purple","orange")) {
lines(rollingEstimate(gibbsRain(20000))[[1]],col = col)
}
plot(rollingEstimate(gibbsRain(20000))[[2]],type = "l",col="red",ylim = c(0,1),main = "Rain",
ylab = "Estimated TRUE frequency")
for (col in c("black","blue","cyan","purple","orange")) {
lines(rollingEstimate(gibbsRain(20000))[[2]],col = col)
}
vec <- c()
vec2 <- c()
for (i in 1:100) {
sample <- gibbsRain(8000)
a <- colMeans(sample)
vec[i] <- a[1]
vec2[i] <- a[2]
}
# Cloudy
mean(vec)
# Rain
mean(vec2)
vec <- c()
vec2 <- c()
for (i in 1:100) {
sample <- gibbsRain(8000)
a <- colMeans(sample)
vec[i] <- a[1]
vec2[i] <- a[2]
}
cat(sprintf("
Cloudy prob: %s
Rain prob:  %s
", mean(vec), mean(vec2)))
jointMat <- matrix(c(0.0396, 0.0495, 0.009, 0.18), ncol = 2)
jointMat
jointMat <- jointMat/sum(jointMat)
jointMat
rowSums(jointMat)
# row is R = (F,T), column is C = (F,T)
jointMat <- matrix(c(0.18, 0.009, 0.0495, 0.0396), ncol = 2)
jointMat <- jointMat/sum(jointMat)
jointMat
gibbsRain <- function(n){
# row is R = (F,T), column is C = (F,T)
jointMat <- matrix(c(0.18, 0.009, 0.0495, 0.0396), ncol = 2)
jointMat <- jointMat/sum(jointMat)
# initiation
CProb <- rep(NA, n)
RProb <- rep(NA, n)
CProb[1] <- rbinom(1,1,0.5)
RProb[1] <- rbinom(1,1,0.5)
# Assigning probability in each round
for (i in 2:n){
if (runif(1) <= 0.5) {
CProb[i] <- rbinom(1, 1, jointMat[RProb[i-1] + 1, 2]/sum(jointMat[,2]))
RProb[i] <- RProb[i-1]
} else {
RProb[i] <- rbinom(1, 1, jointMat[2, CProb[i-1] + 1]/sum(jointMat[2,]))
CProb[i] <- CProb[i-1]
}
}
resultDT <- data.table(Cloudy = CProb, Rain = RProb)
return(resultDT)
}
gibbSamples <- gibbsRain(100)
RMarg <- mean(gibbSamples[, "Rain"])
cat(sprintf("The margina probability is %s", RMarg))
gibbSamples
RMarg <- mean(gibbSamples$Rain)
cat(sprintf("The margina probability is %s", RMarg))
gibbSamplesDT <- as.data.table(gibbSamples)
gibbSamplesDT[, RFreq := cumsum(Rain)/seq_len(.N)]
gibbSamplesDT[, CFreq := cumsum(Cloudy)/seq_len(.N)]
cloudyACF <- acf(gibbSamplesDT$CFreq, plot = FALSE)
rainACT   <- acf(gibbSamplesDT$RFreq, plot = FALSE)
## ESS estimation --------------------------------------
ESSCloudy <- 100/(1+2*sum(cloudyACF$acf))
ESSRain   <- 100/(1+2*sum(cloudyACF$acf))
cat(sprintf("
Cloudy ESS: %s, \n
Rain ESS: %s", ESSCloudy, ESSRain))
gibbSamplesDT <- as.data.table(gibbSamples)
gibbSamplesDT[, RFreq := cumsum(Rain)/seq_len(.N)]
gibbSamplesDT[, CFreq := cumsum(Cloudy)/seq_len(.N)]
cloudyACF <- acf(gibbSamplesDT$CFreq, plot = TRUE)
rainACT   <- acf(gibbSamplesDT$RFreq, plot = TRUE)
## ESS estimation --------------------------------------
ESSCloudy <- 100/(1+2*sum(cloudyACF$acf))
ESSRain   <- 100/(1+2*sum(cloudyACF$acf))
cat(sprintf("
Cloudy ESS: %s, \n
Rain ESS: %s", ESSCloudy, ESSRain))
gibbSamplesDT <- as.data.table(gibbSamples)
gibbSamplesDT[, RFreq := cumsum(Rain)/seq_len(.N)]
gibbSamplesDT[, CFreq := cumsum(Cloudy)/seq_len(.N)]
cloudyACF <- acf(gibbSamplesDT$CFreq, plot = TRUE)
rainACT   <- acf(gibbSamplesDT$RFreq, plot = TRUE)
## ESS estimation --------------------------------------
ESSCloudy <- 100/(1+2*sum(cloudyACF$acf))
ESSRain   <- 100/(1+2*sum(rainACT$acf))
cat(sprintf("
Cloudy ESS: %s, \n
Rain ESS: %s", ESSCloudy, ESSRain))
rollingEstimate <- function(gibbSamples){
cloudy <- 1*(gibbSamples$Cloudy)
rain <- 1*(gibbSamples$Rain)
rollingEstimateCloudy <- cumsum(cloudy) / seq_along(cloudy)
rollingEstimateRain <- cumsum(rain) / seq_along(rain)
return(list(rollingEstimateCloudy,rollingEstimateRain))
}
# sample two 50k long chains
gibbSamples_50k_1 <- gibbsRain(50000)
gibbSamples_50k_2 <- gibbsRain(50000)
rollEsts_50k_1 <- rollingEstimate(gibbSamples_50k_1)
rollEsts_50k_2 <- rollingEstimate(gibbSamples_50k_2)
# plot chains
plot(rollEsts_50k_1[[1]][1:25000],type = "l",col="red",ylim = c(0,1), main = "Cloudy",
ylab = "Estimated TRUE frequency")
lines(rollEsts_50k_2[[1]][1:25000])
plot(rollEsts_50k_1[[2]][1:25000],type = "l",col="red",ylim = c(0,1), main = "Rain",
ylab = "Estimated TRUE frequency")
lines(rollEsts_50k_2[[2]][1:25000])
# plot more then two chains to check on a more general convergence burn-in time
plot(rollingEstimate(gibbsRain(20000))[[1]],type = "l",col="red",ylim = c(0,1),main = "Cloudy",
ylab = "Estimated TRUE frequency")
for (col in c("black","blue","cyan","purple","orange")) {
lines(rollingEstimate(gibbsRain(20000))[[1]],col = col)
}
plot(rollingEstimate(gibbsRain(20000))[[2]],type = "l",col="red",ylim = c(0,1),main = "Rain",
ylab = "Estimated TRUE frequency")
for (col in c("black","blue","cyan","purple","orange")) {
lines(rollingEstimate(gibbsRain(20000))[[2]],col = col)
}
library(coda)
mcmclist <- list()
for (i in 1:10) {
mcmclist[[i]] <- mcmc(gibbsRain(10000)*1)
}
mcmclist <- mcmc.list(mcmclist)
gelman.plot(mcmclist)
vec <- c()
vec2 <- c()
for (i in 1:100) {
sample <- gibbsRain(8000)
a <- colMeans(sample)
vec[i] <- a[1]
vec2[i] <- a[2]
}
cat(sprintf("
Cloudy prob: %s
Rain prob:  %s", mean(vec), mean(vec2)))
gibbsRain <- function(number_samples){
# Constants
P_C = 0.5
P_S_g_C = matrix(c(1,0,0.1,0.5,0.9,0.5),ncol = 3)
P_R_g_C = matrix(c(1,0,0.8,0.2,0.2,0.8),ncol = 3)
P_G_g_S_R = matrix(c(1,1,0,0,1,0,1,0,
0.99,0.90,0.90,0.01,0.01,0.1,0.1,0.99),ncol = 4)
# INITALIZE
states <- matrix(T, number_samples,
ncol = 2,
dimnames = list(c(),c("Rain","Cloudy")))
for (i in 1:(number_samples-1)) {
if (runif(1) >= 0.5) {
# Update Rain
a <- P_R_g_C[2-states[i,"Cloudy"],2]*P_G_g_S_R[1,3]
b <- a + P_R_g_C[2-states[i,"Cloudy"],3]*P_G_g_S_R[2,3]
states[i+1,"Rain"] <- runif(1) <= a/b
states[i+1,"Cloudy"] <- states[i,"Cloudy"]
} else {
# Update Cloudy
a <- P_C*P_S_g_C[1,2]*P_R_g_C[1,3-states[i,"Rain"]]
b <- a + (1-P_C)*P_S_g_C[2,2]*P_R_g_C[2,3-states[i,"Rain"]]
states[i+1,"Cloudy"] <- runif(1) <= a/b
states[i+1,"Rain"] <- states[i,"Rain"]
}
}
return (states)
}
gibbSamples <- gibbsRain(100)
vec <- c()
vec2 <- c()
for (i in 1:100) {
sample <- gibbsRain(8000)
a <- colMeans(sample)
vec[i] <- a[1]
vec2[i] <- a[2]
}
cat(sprintf("
Cloudy prob: %s
Rain prob:  %s", mean(vec), mean(vec2)))
